#pragma section CONST=BANK5
#pragma section CODE=BANK5


//LoROM mememory map
#include <FLOAT.H>
#include <INTTYPES.H>
#include <STDINT.H>
#include <STDIO.H>
#include <STRING.H>
#include <MALLOC.H>
#include <STDIO.H>
#include <STDLIB.H>
#include <STRING.H>



#include "include\SNES.h"
#include "include\initsnes.h"
#include "include\crashHandler.h"
#include "include\imagedata.h"

#define StringCast(sIn) ((unsigned char *)sIn)

//Can't rely on initial variable values, non explicit string constants and global variables
const unsigned char string1[] = "Stack Contents:";
const unsigned char string2[] = "x#### 00 01 02 03 04 05 06 07 ##";
const unsigned char sFourHex[] = "x%4X";
const unsigned char sTwoHex[] = " %2X";
const unsigned char string5[] = "test";
const unsigned char sX[] = "x";
const unsigned char sSpace[] = " ";





const unsigned char SNESFONT_bin[1016] = {
    0x99, 0x5A, 0x3C, 0xFF, 0xFF, 0x3C, 0x5A, 0x99, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00, 0x00,
    0x66, 0x66, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x7E, 0x28, 0x7E, 0x28, 0x00, 0x00,
    0x3C, 0x6A, 0x7C, 0x3E, 0x56, 0x3C, 0x10, 0x00, 0x22, 0x54, 0x28, 0x14, 0x2A, 0x44, 0x00, 0x00,
    0x30, 0x48, 0x32, 0x4C, 0x4C, 0x32, 0x00, 0x00, 0x18, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30,
    0x18, 0x7E, 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,
    0x3A, 0x64, 0x4A, 0x52, 0x26, 0x5C, 0x00, 0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00,
    0x38, 0x4C, 0x0C, 0x18, 0x30, 0x7E, 0x00, 0x00, 0x3C, 0x46, 0x1C, 0x06, 0x46, 0x3C, 0x00, 0x00,
    0x0C, 0x1C, 0x2C, 0x4C, 0x7E, 0x0C, 0x00, 0x00, 0x7E, 0x60, 0x7C, 0x06, 0x46, 0x3C, 0x00, 0x00,
    0x3C, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x7E, 0x66, 0x0C, 0x3E, 0x18, 0x18, 0x00, 0x00,
    0x3C, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x3E, 0x06, 0x3C, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x10, 0x00,
    0x00, 0x06, 0x18, 0x60, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x18, 0x06, 0x18, 0x60, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x0C, 0x18, 0x00, 0x18, 0x00,
    0x7C, 0x82, 0xBA, 0xAA, 0xBE, 0x40, 0x3E, 0x00, 0x18, 0x3C, 0x24, 0x7E, 0x66, 0x66, 0x00, 0x00,
    0x7C, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x62, 0x7E, 0x3C, 0x00, 0x00,
    0x7C, 0x66, 0x66, 0x66, 0x7E, 0x7C, 0x00, 0x00, 0x7E, 0x60, 0x7C, 0x60, 0x7E, 0x7E, 0x00, 0x00,
    0x7E, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x6E, 0x66, 0x3C, 0x00, 0x00,
    0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x7E, 0x00, 0x00,
    0x3E, 0x0C, 0x0C, 0x4C, 0x7C, 0x38, 0x00, 0x00, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x00, 0x00,
    0x60, 0x60, 0x60, 0x60, 0x7E, 0x7E, 0x00, 0x00, 0x42, 0x66, 0x7E, 0x5A, 0x5A, 0x42, 0x00, 0x00,
    0x46, 0x66, 0x76, 0x7E, 0x6E, 0x66, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x3C, 0x00, 0x00,
    0x7C, 0x66, 0x7E, 0x7C, 0x60, 0x60, 0x00, 0x00, 0x3C, 0x66, 0x62, 0x6A, 0x7E, 0x3C, 0x02, 0x00,
    0x7C, 0x66, 0x7E, 0x7C, 0x6C, 0x66, 0x00, 0x00, 0x3C, 0x62, 0x7C, 0x3E, 0x46, 0x3C, 0x00, 0x00,
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x3C, 0x00, 0x00,
    0x66, 0x66, 0x66, 0x24, 0x3C, 0x18, 0x00, 0x00, 0x42, 0x5A, 0x5A, 0x7E, 0x66, 0x42, 0x00, 0x00,
    0x66, 0x3C, 0x18, 0x3C, 0x66, 0x42, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x00,
    0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x7E, 0x00, 0x00, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1C,
    0x40, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x38,
    0x18, 0x24, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0x18, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x64, 0x64, 0x3A, 0x00, 0x00,
    0x30, 0x30, 0x3C, 0x32, 0x32, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x60, 0x62, 0x3C, 0x00, 0x00,
    0x0C, 0x0C, 0x3C, 0x4C, 0x4C, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x38, 0x68, 0x72, 0x3C, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x32, 0x30, 0x7C, 0x30, 0x30, 0x00, 0x00, 0x3A, 0x66, 0x66, 0x3E, 0x46, 0x3C,
    0x60, 0x60, 0x7C, 0x62, 0x62, 0x62, 0x00, 0x00, 0x30, 0x00, 0x30, 0x30, 0x34, 0x18, 0x00, 0x00,
    0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x46, 0x3C, 0x60, 0x64, 0x68, 0x78, 0x64, 0x62, 0x00, 0x00,
    0x30, 0x30, 0x30, 0x30, 0x34, 0x18, 0x00, 0x00, 0x00, 0x00, 0x54, 0x6A, 0x6A, 0x62, 0x00, 0x00,
    0x00, 0x00, 0x5C, 0x62, 0x62, 0x62, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x62, 0x62, 0x3C, 0x00, 0x00,
    0x00, 0x00, 0x5C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x00, 0x00, 0x34, 0x4C, 0x4C, 0x3C, 0x0E, 0x0C,
    0x00, 0x00, 0x5C, 0x62, 0x60, 0x60, 0x00, 0x00, 0x00, 0x3C, 0x62, 0x18, 0x46, 0x3C, 0x00, 0x00,
    0x30, 0x30, 0x78, 0x30, 0x32, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3A, 0x00, 0x00,
    0x00, 0x00, 0x62, 0x62, 0x34, 0x18, 0x00, 0x00, 0x00, 0x00, 0x42, 0x5A, 0x5A, 0x2C, 0x00, 0x00,
    0x00, 0x00, 0x62, 0x34, 0x18, 0x66, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x46, 0x3C,
    0x00, 0x00, 0x7E, 0x0C, 0x30, 0x7E, 0x00, 0x00, 0x1C, 0x30, 0x30, 0x18, 0x18, 0x30, 0x30, 0x1C,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x38, 0x0C, 0x0C, 0x18, 0x18, 0x0C, 0x0C, 0x38,
    0x00, 0x00, 0x70, 0x5A, 0x0E, 0x00, 0x00, 0x00
};


void reverse(char *s)
{
   int length, c;
   char *begin, *end, temp;
 
   length = strlen(s);
   begin  = s;
   end    = s;
 
   for (c = 0; c < length - 1; c++)
      end++;
 
   for (c = 0; c < length/2; c++)
   {        
      temp   = *end;
      *end   = *begin;
      *begin = temp;
 
      begin++;
      end--;
   }
}

// Implementation of itoa() 
char* itoaNew(int num, char* str, int base) 
{ 
    int i; 
    int isNegative; 
	
	i = 0;
	isNegative = 0;
  
    /* Handle 0 explicitely, otherwise empty string is printed for 0 */
    if (num == 0) 
    { 
        str[i] = '0'; 
        i++;
		str[i] = '\0'; 
        return str; 
    } 
  
    // In standard itoa(), negative numbers are handled only with  
    // base 10. Otherwise numbers are considered unsigned. 
    if (num < 0 && base == 10) 
    { 
        isNegative = 1; 
        num = -num; 
    } 
  
    // Process individual digits 
    while (num != 0) 
    { 
        int rem = num % base; 
        str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0'; 
        num = num/base; 
    } 
  
    // If number is negative, append '-' 
    if (isNegative) 
        str[i++] = '-'; 
  
    str[i] = '\0'; // Append string terminator 
  
    // Reverse the string 
    reverse(str); 
  
    return str; 
} 

void WaitVram(void) {
	int8_t regRead1;
	do{ //Wait for Vblank
		regRead1 = REG_RDNMI;
	} while( (regRead1 > 0));
}

void far CrashHandler(void){
	char Stack1;
	char Stack2;
	char Stack3;
	char Stack4;
	char Stack5;
	char buffer[80];
	char subBuffer[8];
	uint8_t *pCurrentLineRam;
	uint8_t *pCurrentByteRam;
	uint8_t curByte;
	uint32_t PreviousLine;
	int i;
	int DisplayLine;
	int DisplayCounter;
	
	//Display in the debugger that it crashed
	Stack1 = 'C';
	Stack2 = 'r';
	Stack3 = 'a';
	Stack4 = 's';
	Stack5 = 'h';
	//Get a pointer to the top of ram
	pCurrentLineRam = ((uint8_t*)0x002000);
	DisplayLine = 0;
	
	REG_NMITIMEN = 0x00;
	
	termM0Init();
	termM0PrintStringXY(StringCast(string1),0,DisplayLine);
	DisplayLine++;
	termM0PrintStringXY(StringCast(string2),0,DisplayLine);
	DisplayLine++;
	
	/* sprintf is broken without the initialisation phase so here is a workaround
	strcpy(buffer,sX);
	itoaNew(0x78,subBuffer,16);
	strcat(buffer,subBuffer);
	termM0PrintStringXY(buffer,0,DisplayLine);
	DisplayLine++;
	*/
	
	for (DisplayCounter = 0; DisplayCounter < 12; DisplayCounter++) {		
		pCurrentByteRam = pCurrentLineRam-0x0010;
		//sprintf(buffer,sFourHex,pCurrentByteRam);
		strcpy(buffer,sX);
		itoaNew((uint32_t)pCurrentByteRam,subBuffer,16);
		strcat(buffer,subBuffer);
		strcat(buffer,sSpace);
		
		
		for (i = 0; i < 8; i++) {	
			curByte = *pCurrentByteRam;
			//sprintf(subBuffer,sTwoHex,curByte);
			itoaNew(curByte,subBuffer,16);
			strcat(buffer,subBuffer);
			if (curByte < 16) {
				strcat(buffer,sSpace);
			}
			strcat(buffer,sSpace);
			
			pCurrentByteRam++;
		}
		termM0PrintStringXY(StringCast(buffer),0,DisplayLine);
		DisplayLine++;

		
		
		pCurrentLineRam -= 0x0008;
		pCurrentByteRam = pCurrentLineRam;
		//sprintf(buffer,sFourHex,pCurrentByteRam);
		strcpy(buffer,sX);
		itoaNew((uint32_t)pCurrentByteRam,subBuffer,16);
		strcat(buffer,subBuffer);
		strcat(buffer,sSpace);
		
		for (i = 0; i < 8; i++) {	
			curByte = *pCurrentByteRam;
			//sprintf(subBuffer,sTwoHex,curByte);
			itoaNew(curByte,subBuffer,16);
			strcat(buffer,subBuffer);
			if (curByte < 16) {
				strcat(buffer,sSpace);
			}
			strcat(buffer,sSpace);
			
			pCurrentByteRam++;
		}
		termM0PrintStringXY(StringCast(buffer),0,DisplayLine);
		DisplayLine++;
	}
	
	
	for (;;){
		sprintf(buffer,"test");
	}
}


//If I put this inside a function, the constant is generated at the functions
//entry point and thus it tries to execute it like code
const unsigned char BGPAL[] = {0x00,0x00,0xFF,0x7F};
const unsigned char BGCLEAR[] = {0x20, 0x00};

int termM0Init(void){	
	WaitVram();
	LoadCGRam(BGPAL, 0x00, 4, 0); // Load BG Palette Data
	WaitVram();
	ClearVram(BGCLEAR, 0x0000, sizeof(SNESFONT_bin), 0); // Clear VRAM for font
	WaitVram();
	LoadLoVram(SNESFONT_bin, 0x0000, sizeof(SNESFONT_bin), 7);

	WaitVram();
	ClearVram(BGCLEAR, 0xF800, 0x400, 0); // Clear VRAM Map To Fixed Tile Word
	
	REG_BGMODE  = 0x08;
	REG_BG1SC  = 0xFC;
	REG_BG12NBA = 0x00;
	REG_TM = 0x01;
	
	REG_BG1HOFS = 0x00;
	REG_BG1HOFS = 0x00;
	REG_BG1VOFS = 0x00;
	REG_BG1VOFS = 0x00;	
	return 0;
}
//Takes an input and maps prints to an xy on the tile
int termM0PrintStringXY(char *szInput, int inpX, int inpY){
	WaitVram();
	LoadLoVram(szInput, 0xF800+inpX+inpY*0x40, strlen(szInput), 0); // Load Text To VRAM Lo Bytes
	return 0;
}

//Takes an input and maps prints to an xy on the tile
int termM0PrintString(const char *szInput){
	static uint16_t curWritePos = 0xF800;
	uint8_t *test_heap;
	uint8_t curOffset = 0;
	int i;
	test_heap = (uint8_t*)farmalloc((uint32_t)(strlen(szInput)+1));
	//strcpy(test_heap,szInput);
	for (i = 0; i < (strlen(szInput)+1); i++){
		if( (szInput[i] == '\n') ) {
			curOffset = i;
			if (strlen(test_heap) != 0){
				LoadLoVram(test_heap, curWritePos, strlen(test_heap), 0); // Load Text To VRAM Lo Bytes
				curWritePos = curWritePos + (strlen(test_heap) << 1);
			}
			curOffset = i + 1;
			//Change edgecase behaviour
			/*if ( (curWritePos & 0x003F) != 0x0000 ){
			//	curWritePos = (curWritePos & 0xFFC0) + 0x40;	
			}*/
			curWritePos = (curWritePos & 0xFFC0) + 0x40;
		}
		else if( (szInput[i] == '\r') ) {
			if (strlen(test_heap) != 0){
				LoadLoVram(test_heap, curWritePos, strlen(test_heap), 0); // Load Text To VRAM Lo Bytes
			}
			curOffset = i + 1;
			curWritePos = (curWritePos & 0xFFC0);
		}
		else if( (szInput[i] == '\0') ) {
			test_heap[i-curOffset] = '\0';
			if (strlen(test_heap) != 0){
				LoadLoVram(test_heap, curWritePos, strlen(test_heap), 0); // Load Text To VRAM Lo Bytes
				curWritePos = curWritePos + (strlen(test_heap) << 1);
			}
			curOffset = i + 1;
		}
		test_heap[i-curOffset] = szInput[i];
		test_heap[i-curOffset+1] = '\0';
	}
	farfree(test_heap);
	return 0;
}